<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>restful</title>
      <link href="/2021/06/26/restful/restful/"/>
      <url>/2021/06/26/restful/restful/</url>
      
        <content type="html"><![CDATA[<p>读懂进程、线程、协程的概念~</p><p>这篇文章我们来讨论restful风格~</p><span id="more"></span><h2 id="REST详解"><a href="#REST详解" class="headerlink" title="REST详解"></a>REST详解</h2><p>​    首先我们要理清一个概念：<strong>REST</strong>。</p><p>​    REST全称是Representational State Transfer，中文意思是表述性状态转移。 </p><blockquote><p>也有说全称是 Resource Representational State Transfer  资源表现状态转移</p></blockquote><p>​    它是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。</p><p>​    表现层状态转换是根基于超文本传输协议(HTTP)之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。符合或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质(interoperability)。相对于其它种类的网络服务，例如 SOAP服务则是以本身所定义的操作集，来访问网络上的资源。</p><blockquote><p>（摘自维基百科）</p></blockquote><p>​    概念一般都比较晦涩难懂，我们看一下知乎大神给出的简洁版介绍：</p><p>​    1.REST不是”rest”这个单词，而是几个单词缩写。但即使那几个单词说出来，也无法理解在说什么 -_-!! （不是要贬低人，是我自己也理解困难）；</p><p>​    2.REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）；</p><p>​    3.Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。比如：</p><p>​    URL全局资源定位符  locat   restful</p><p>​    URI:全局资源标识符  identify</p><p><code>    http://api.qc.com/v1/newsfeed</code>: 获取某人的新鲜;<br><code>    http://api.qc.com/v1/friends</code>: 获取某人的好友列表;<br><code>    http://api.qc.com/v1/profile</code>: 获取某人的详细信息;</p><p>​    4 .用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：</p><p><img src="/1565331217181.png"></p><p>​    比如：<br>​    DELETE <code>http://api.qc.com/v1/friends</code>: 删除某人的好友 （在http parameter指定好友id）<br>​    POST <code>http://api.qc.com/v1/</code>friends: 添加好友<br>​    UPDATE <code>http://api.qc.com/v1/profile</code>: 更新个人资料</p><p>​    禁止使用： GET <code>http://api.qc.com/v1/deleteFriend</code></p><p>​    5.通过状态码判断操作结果：</p><p>​    参考这篇文章：<a href="https://www.cnblogs.com/xflonga/p/9368993.html">常见的HTTP状态码 - xflonga - 博客园 (cnblogs.com)</a></p><h2 id="Restful的好处"><a href="#Restful的好处" class="headerlink" title="Restful的好处"></a><strong>Restful的好处</strong></h2><ul><li><p>轻量，直接基于http，不再需要任何别的诸如消息协议。get/post/put/delete为CRUD操作</p></li><li><p>面向资源，一目了然，具有自解释性。</p></li><li><p>数据描述简单，一般以xml，json做数据交换。</p></li><li><p>无状态，在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度。</p></li><li><p>简单、低耦合</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程、协程</title>
      <link href="/2021/06/25/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
      <url>/2021/06/25/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>读懂进程、线程、协程的概念~</p><span id="more"></span><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>​    cpu是计算机的核心，承担了所有计算任务；而操作系统是计算机的管理者，负责任务调度、资源分配、硬件管理；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>​    进程是一个具有一定独立功能的程序，在一组数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p><p>​    进程是一种抽象的概念，从来没有统一标准的定义。</p><p>​    进程一般由程序、数据集合和进程控制块（PCB）三部分组成。</p><p>​    程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块（PCB）包含进程的描述信息和控制信息，是进程存在的唯一标志。</p><p>​    进程特征：</p><ol><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li><li>并发性：任何进程都可以同其他进程一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序、数据和PCB三部分组成。</li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>​    早期的操作系统并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p><p>​    后来随着计算机硬件的发展，对cpu要求越来越高，进程之间的切换开销比较大，已经无法满足越来越复杂的程序要求了，于是线程应运而生。</p><p>​    线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程id、当前指令指针pc、寄存器和堆栈组成，而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。</p><p>​    查看Windows任务管理器，发现一个进程通常是分了多个线程的:</p><p><img src="/img%5C%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.jpg"></p><p>​    有时候，线程也称为轻量级的进程。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h3><p>​    传统的J2EE系统中都是基于每个请求，占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>​    最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让cpu一直等待I/O返回，说白了线程根本没有利用cpu去做运算，而是处于空转状态。另外过多的线程，也会带来更多的上下文切换开销。</p><p>​    对于上述问题，现阶段行业里比较流行的解决方案之一就是单线程加上异步回调。其代表派便是node.js以及java里的新秀vert.x</p><p>​    而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除上下文切换上的开销。</p><h3 id="协程特点"><a href="#协程特点" class="headerlink" title="协程特点"></a>协程特点</h3><ol><li>线程的切换由操作系统负责调度，协程由用户自己调度，因此减少了上下文切换，提高了效率；</li><li>线程默认stack大小时1M，而协程更轻量，接近1k，因此协程也称为轻量级线程，可以在相同的内存中开启更多协程；</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li><li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到这种情况，更好使用线程去解决。</li></ol><h3 id="协程原理"><a href="#协程原理" class="headerlink" title="协程原理"></a>协程原理</h3><p>​    当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放在这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为fiber，比如golang里的go关键字其实就是负责开启一个fiber，让func逻辑跑在上面。</p><p>​    由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上，因此，协程的开销远远小于线程的开销，也就没有了上下文切换上的开销。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 协程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="/2021/06/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/06/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>聊一聊golang中的深拷贝和浅拷贝。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    golang开发时，我们会经常的把一个变量赋值给另一个变量，这个过程可能发生深拷贝也可能发生浅拷贝，二者有什么区别和联系呢？</p><h3 id="1、深拷贝（Deep-Copy）"><a href="#1、深拷贝（Deep-Copy）" class="headerlink" title="1、深拷贝（Deep Copy）"></a>1、深拷贝（Deep Copy）</h3><p>​    深拷贝，拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。</p><p>​    值类型的数据，默认全部都是深拷贝，Array、Int、String、Struct、Float，Bool。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b := a<span class="comment">//深拷贝</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">4</span> <span class="comment">//修改数组b的值，不影响数组a</span></span><br><span class="line">fmt.Println(a,b) <span class="comment">//[1 2 3] [4 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、浅拷贝（Shallow-Copy）"><a href="#2、浅拷贝（Shallow-Copy）" class="headerlink" title="2、浅拷贝（Shallow Copy）"></a>2、浅拷贝（Shallow Copy）</h3><p>​    浅拷贝，拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。</p><p>​    引用类型的数据，默认全部都是浅拷贝，Slice，Map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//定义一个切片</span></span><br><span class="line">b := a <span class="comment">//浅拷贝</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">4</span><span class="comment">//修改b的值，a的值也会跟着变</span></span><br><span class="line">fmt.Println(a,b)<span class="comment">//[4 2 3] [4 2 3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//map同样也是浅拷贝</span></span><br><span class="line">    c := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;<span class="string">&quot;柯南&quot;</span>:<span class="number">98</span>,<span class="string">&quot;lufy&quot;</span>:<span class="number">75</span>,<span class="string">&quot;naruto&quot;</span>:<span class="number">86</span>&#125;</span><br><span class="line">d := c</span><br><span class="line">d[<span class="string">&quot;lufy&quot;</span>] = <span class="number">88</span></span><br><span class="line">fmt.Println(c,d)<span class="comment">//map[lufy:88 naruto:86 柯南:98] map[lufy:88 naruto:86 柯南:98]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>​    深拷贝和浅拷贝的本质区别，在于是否真正获取（复制）对象实体，而不是仅仅引用。</p><h2 id="扩容摆脱同根"><a href="#扩容摆脱同根" class="headerlink" title="扩容摆脱同根"></a>扩容摆脱同根</h2><p>​    从上述例子看出来，slice若不是深拷贝，或者重新生成新空间，无论通过参数传递还是使用 ：= 或者 [:]赋值都存在同根性。    </p><p>​    而扩容可以摆脱这种同根性。</p><p>​    Slice与Array最大的区别在于Slice不需要指定大小会自动扩容等一些特性，Slice在多次append元素时，若满足扩容策略，这时候内部就会重新申请一块内存空间，将原本的元素拷贝一份到新的内存空间上。此时其与原本的数组就没有任何关联关系了，再进行修改值也不会变动到原始数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//定义一个切片</span></span><br><span class="line">    b := a[<span class="number">0</span>:<span class="number">1</span>] </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=<span class="number">6</span>;i++&#123;</span><br><span class="line">        b = <span class="built_in">append</span>(b,i) <span class="comment">//容量未满时是浅拷贝，一旦扩容就是深拷贝了</span></span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">//验证</span></span><br><span class="line">fmt.Println(a,b)<span class="comment">//[1 0 1] [10 0 1 2 3 4 5 6]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 深拷贝与浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis中的数据结构</title>
      <link href="/2021/06/24/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/06/24/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis是一个高性能的分布式内存数据库，目前在国内外个大互联网公司中都有着广泛的使用，即使是一些非互联网公司也有着非常重要的使用场景。</p><span id="more"></span><p>Redis提供了五种主要的数据类型，它提供了强大且实用的功能，然而实际开发中，有大多数的开发者仅仅只会使用简单的 Redis String的 Get和Set，下面将回顾Redis五大对象，以便能够在实战中游刃有余。</p><ul><li>String（终究是我扛下来所有）</li><li>Hash（存储对象我也行）</li><li>List（栈和队列我都行）</li><li>Set（标签系统我在行）</li><li>Sort Set（排起名来我最棒）</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类型是Redis最基础的数据结构，其他几种数据结构都是在字符串类型基础上构建的。字符串类型的值是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频）等。</p><p><img src="/./image-20200626095844113.png" alt="image-20200626095844113"></p><p>字符串对象的内部编码有3种 ：<strong>int</strong>、<strong>raw</strong> 和 <strong>embstr</strong>，Redis会根据当前值的类型和长度来决定使用哪种编码来实现</p><ul><li>int：如果一个字符串对象保存的是整数值,并且这个整数值可以用<code>long</code>类型来表示</li><li>raw：如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节</li><li>embstr：如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节</li></ul><p>Reids字符串的使用场景是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去),这让本身很单纯的字符串承受了它这个年纪本不该承受的重量。其实Redis的主要使用场景主要有以下几种:</p><ul><li>作为缓存层,缓存热点数据</li><li>Redis字符串可以自增自减的特性可以用来做计数器、限速器、自增ID生成等</li><li>分布式系统的Session共享</li><li>二进制数据的存储</li></ul><p>关于更加详细的关于字符串结构的介绍，参考<a href="https://blog.laoyu.site/2019/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2(String)">这篇博客</a></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希对象用来存储一组数据对。每个数据对又包含键值两部分</p><p><img src="/./image-20200626101327742.png" alt="image-20200626101327742"></p><p>Hash对象也有两种实现方式：<a href="https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8">ziplist（压缩列表）</a>和 <a href="https://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8">hashtable（哈希表）</a></p><p>同样，只有当存储的数据量比较小的情况下，Redis才使用压缩列表来实现哈希对象，具体需要满足两个条件</p><ul><li>字典中保存的键和值的大小都要小于64字节</li><li>字典中键值对的个数要小于512个</li></ul><p>当不能同时满足上面的两个条件时，Redis就使用哈希表来实现Hash对象</p><p>当存储的内容是对象的时候，Redis字符串对象很多功能使用Redis 哈希对象也可以实现，如缓存用户信息的时候，使用Redis哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。</p><p>但是也有其缺点，就是要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable将会消耗更多的内存。</p><p>此外，Hash对象还可以实现购物车和计数器等功能，更详细的介绍，参考<a href="https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C(Hash)">这篇博客</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表这种对象支持存储一组有序的，不重复的数据。因为其有序性，它可以获取指定范围的元素列表，可以在O(1)的时间复杂度获取指定索引的下标的元素等。</p><p><img src="/./image-20200626105857594.png" alt="image-20200626105857594"></p><p>在Redis3.2版本以前列表类型的内部编码有两种。当满足下面两个条件的时候，Redis 列表对象使用ziplist（压缩列表）来实现。</p><ul><li>当列表的元素个数小于list-max-ziplist-entries配置（默认512个）</li><li>当列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节）</li></ul><p>当列表类型无法满足ziplist条件时，Redis会使用linkedList作为列表的内部实现。</p><p>而在Redis3.2版本开始怼列表数据结构进行改造，使用quickList代替了zipList和linkedList。</p><p>由于列表对象的有序且不可重复的特性，它比较适合用来做文章、商品等列表的存储。</p><p>列表类型可以lpush（左侧push），同时又可以使用rpop（右侧弹出）第一个元素，所以列表类型具有先进先出的特性，可以用来实现消息队列，也可以lpush（左侧push）和lpop（左侧弹出），具有后进先出的特性，因此开发中需要使用栈的时候，我们可以使用列表对象来实现。</p><p>关于List更详细的介绍，参考<a href="https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8(List)">这篇博客</a></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合对象是一个无序且唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储，与列表不同的是它存储的数据是无序且不重复的。</p><p><img src="/./image-20200626122033221.png" alt="image-20200626122033221"></p><p>集合对象的内部编码也有两种，intest（整数集合）与hashtable（哈希表），当满足下面两个条件的时候，集合对象使用intset来实现</p><ul><li>集合中的元素都是整数</li><li>集合中元素的个数小于 set-maxintset-entries配置（默认512个）</li></ul><p>不满足上面两个条件时，集合对象使用hashtable来实现</p><p>集合对象的主要两个特性就是：<strong>无序</strong>，<strong>不可重复</strong>，<strong>支持并交差</strong>，因此可以用来做标签系统</p><p>而集合中的 <a href="https://blog.laoyu.site/2020/redis_command/set/spop/">SPOP(随机移除并返回集合中一个或多个元素)</a> 和 <a href="https://blog.laoyu.site/2020/redis_command/set/srandmember/">SRANDMEMBER(随机返回集合中一个或多个元素)</a> 命令可以帮助我们实现一个抽奖系统</p><p>有关Set更详细的介绍，参考<a href="https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E9%9B%86%E5%90%88(Set)/">这篇博客</a></p><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。</p><p><img src="/./image-20200626123309037.png" alt="image-20200626123309037"></p><p>有序集合是由 <a href="http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/">ziplist (压缩列表)</a> 或 <a href="https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/">skiplist (跳跃表)</a> 组成的。</p><p>当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：</p><ul><li>有序集合保存的元素个数要小于 128 个；</li><li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li></ul><p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。</p><p>有序集合比较典型的使用场景就是排行榜系统例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等。</p><p>有关Redis有序集合对象的更详细的介绍，参考<a href="https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88(ZSet)/">这篇博客</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Redis提供了五种最基础也是最常用的对象(数据类型)：String、Hash、List、Set、ZSet。了解这五种对象的有助于我们更好的在日常开发中对Redis进行使用。而通过这篇文章我们可以看到每种对象都是通过多种数据结构来实现的，大家可以思考一下为什么。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不到大梦初醒的时间，你就继续睡眠~</title>
      <link href="/2021/06/23/%E4%B8%8D%E5%88%B0%E5%A4%A7%E6%A2%A6%E5%88%9D%E9%86%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BD%A0%E5%B0%B1%E7%BB%A7%E7%BB%AD%E7%9D%A1%E7%9C%A0/%E4%B8%8D%E5%88%B0%E5%A4%A7%E6%A2%A6%E5%88%9D%E9%86%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BD%A0%E5%B0%B1%E7%BB%A7%E7%BB%AD%E7%9D%A1%E7%9C%A0/"/>
      <url>/2021/06/23/%E4%B8%8D%E5%88%B0%E5%A4%A7%E6%A2%A6%E5%88%9D%E9%86%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BD%A0%E5%B0%B1%E7%BB%A7%E7%BB%AD%E7%9D%A1%E7%9C%A0/%E4%B8%8D%E5%88%B0%E5%A4%A7%E6%A2%A6%E5%88%9D%E9%86%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BD%A0%E5%B0%B1%E7%BB%A7%E7%BB%AD%E7%9D%A1%E7%9C%A0/</url>
      
        <content type="html"><![CDATA[<p>这个季节的武汉，即使是晚上，竟然也有了30°C的气温。</p><p>挥别四月未久，夏天就轰轰烈烈的赶来~</p><span id="more"></span><p>于是你看，在小公园夜跑到第八圈，</p><p>所有清醒的意识全都蒸发成水汽，从头顶上噗噗散开~</p><p>湖边那座小风车慢悠悠的转，一片一片的郁金香蔫到抬不起头。</p><p>我好像没有陪你看过太多风景，是不是这个原因，你才对糖葫芦念念不忘呀</p><p>绿化带里面的灯珠，漆黑到隐了身，融进夜色里，</p><p>于是那些暗暗的灯球像是漂浮在空气里。</p><p>我不免想起来总是飘来飘去的你，像是一头安静不下来的小兽，</p><p>昂着头街头巷尾的撞。</p><p>然后想着想着又出了神，耳机里的歌是一句没听，</p><p>芒果千层的香味先从头脑里钻入鼻孔。</p><p>还有没看完的电影，关于某瓶可乐，以及忘记丢下楼的垃圾。。</p><p>好像过了多少年，还是那个一想事情就容易出神的自己。</p><p>一万束思绪同时蓄力，突破屏障，疯长成藤蔓呼啸向上拔节。</p><p>周小小走后武汉没有下过雨，这么热</p><p>或许等下次她离开就悄悄的，她的火车可以对天神保密~</p><p><img src="/./123.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 小小 </tag>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang的一些坑（初级）</title>
      <link href="/2021/06/22/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/"/>
      <url>/2021/06/22/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>新手踩坑系列…</p><span id="more"></span><p>原文地址：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html</a></p><ol><li><p>不允许左大括号单独一行。go遵循分号注入规则，编译器会在每行代码尾部特定分隔符后加”;”来分割多条语句，比如会在”)”后加分号。相比其他大多数语言，”{“位置由编程人员决定，go这样做结束了各种风格的代码之争。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>                    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span>;    // 无函数体</span>                    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许出现未使用的变量。有一个例外，如果声明的是全局变量，未使用也不会报错；但如果函数内部声明的变量未使用，代码将无法编译。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example <span class="keyword">int</span><span class="comment">//全局变量未使用，也不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">name = <span class="string">&quot;花椰子&quot;</span> <span class="comment">//Ctrl + Alt +l 可以快速格式化代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">age = <span class="number">20</span><span class="comment">//即使赋了值，但是未使用，也会报错</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;name:&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许出现未使用的import。如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p><p>解决方法：可以使用”_”作为引入包的别名，这样的话就会自动去调用引入包的init函数，不会因为未使用而报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span>    <span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>    <span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = log.Println</span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>短的变量声明（Short Variable Declarations）只能在函数内部使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;花椰子&quot;</span> <span class="comment">//全局变量只能通过var来声明</span></span><br><span class="line">age := <span class="number">17</span><span class="comment">//error不能通过短变量声明来声明全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能使用短变量声明重复声明，左边至少要有一个新的变量。</p></li><li><p>不能使用短变量声明这种方式来设置字段值。</p><p>struct的变量字段，不能把”:=”当成”=”来赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> girl <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">look</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pretty&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zxx girl</span><br><span class="line">    zxx.arg, err := look()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;girl: %+v\n&quot;</span>, zxx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zxx girl</span><br><span class="line">    <span class="keyword">var</span> err error    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    zxx.arg, err = look()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;girl: %+v\n&quot;</span>, zxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>意外的变量幽灵（Accidental Variable Shadowing）。</p><p>短变量声明简洁好用，我们使用频率很高。但他同时也可能让人误会是一个赋值操作符，而造成变量覆盖等一系列问题。</p><p>例如代码块中使用短变量声明与外部相同的变量时，没有语法编译错误，但是代码块中同名短变量声明从开始到结束，对变量的修改将不会影响到外部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;花椰子&quot;</span> <span class="comment">//全局变量只能通过var来声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">age := <span class="number">17</span></span><br><span class="line">name := <span class="string">&quot;种植员先生&quot;</span></span><br><span class="line">fmt.Println(name,age)<span class="comment">//种植员先生 17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种现象称之为幽灵变量，可以使用go tool vet -shadow file.go检查幽灵变量。</p></li><li><p>不能使用nil初始化一个未指定类型的变量。</p><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> addr = <span class="literal">nil</span> <span class="comment">//显式类型的变量无法使用nil来初始化</span></span><br><span class="line">    <span class="keyword">var</span> member <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span> <span class="comment">//ok</span></span><br><span class="line">fmt.Println(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接使用值为nil的slice和map。</p><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>map使用make分配内存时可指定capicity容量，但是不能对map使用cap函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//切片可以</span></span><br><span class="line">    n := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">99</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="built_in">cap</span>(n)) <span class="comment">//99</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p>字符串不允许使用nil值。</p><p>golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;    <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span>    <span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组用于函数传参时是值复制。</p><p>在 C/C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p><p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的。</p><p>注意：方法或者函数调用时，传入参数都是值复制（跟赋值一致），除非是map、slice、channel、指针类型这些特殊类型是引用传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">num := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组在函数中传参是值复制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">fmt.Println(arr) <span class="comment">//[0 2 3]</span></span><br><span class="line">&#125;(num)</span><br><span class="line">fmt.Println(num)       <span class="comment">//因为是值传递，所以num仍然是 [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.可以使用数组指针实现引用传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">(*arr)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">fmt.Println(arr) <span class="comment">// &amp;[0 2 3]</span></span><br><span class="line">&#125;(&amp;num)</span><br><span class="line">fmt.Println(num)  <span class="comment">//此时已经是引用传递处理之后，所以num是 [0 2 3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.直接使用 slice：</span></span><br><span class="line">    <span class="comment">//即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</span></span><br><span class="line">    x := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">num := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span>(num) &#123;</span><br><span class="line">fmt.Println(i,v) <span class="comment">//分别打印索引以及数据值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(num)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>slice和array是一维的。</p><p>go表面上看起来像多维的(支持多维的array和slice)，可以创建包含数组的数组，包含切片的切片，实际上只是一维的。</p><p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p><p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p><ol><li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</li><li>使用“独立”的切片分两步：</li></ol><ul><li><p>创建外部 slice</p><ul><li><p>对每个内部 slice 进行内存分配</p><p>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用“共享底层数组”的切片</li></ol><ul><li>创建一个存放原始数据的容器 slice</li><li>创建其他的 slice</li><li>切割原始 slice 来初始化其他的 slice</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化原始 slice</span></span><br><span class="line">    fmt.Println(raw, &amp;raw[<span class="number">4</span>])    <span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120 </span></span><br><span class="line">    </span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>, h)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">        table[i] = raw[i*w : i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])    <span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于多维数组的参考:</p><p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p><p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p></li><li><p>如果从一个不存在key的map中取值，返回的总是对应数据类型的”0值”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">fmt.Println(m[<span class="string">&quot;one&quot;</span>]) <span class="comment">//返回bool的&quot;0值&quot;：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    _,ok := m[<span class="string">&quot;one&quot;</span>]</span><br><span class="line">fmt.Println(ok) <span class="comment">//&quot;one&quot;key不存在，所以返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串的某一位字符是不能指定的。</p><p>string类型的值是常量。尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p><p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">S := <span class="string">&quot;text&quot;</span></span><br><span class="line"><span class="comment">//S[0] = &#x27;T&#x27;       // 不能指定S[0]的值</span></span><br><span class="line"></span><br><span class="line">Stytes := []<span class="keyword">byte</span>(S)</span><br><span class="line">Stytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>     <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(Stytes)) <span class="comment">//Text</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意： 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">    x := &quot;text&quot;</span></span><br><span class="line"><span class="comment">    xRunes := []rune(x)</span></span><br><span class="line"><span class="comment">    xRunes[0] = &#x27;我&#x27;</span></span><br><span class="line"><span class="comment">    x = string(xRunes)</span></span><br><span class="line"><span class="comment">    fmt.Println(x)    // 我ext</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>字符串与[]byte之间的转换是复制（有内存损耗）。</p><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p><p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p><ul><li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li><li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li></ul></li><li><p>string的索引操作返回的是byte（或uint8），如想获取字符可使用for range，也可使用<code>unicode/utf8</code>包和<code>golang.org/x/exp/utf8string</code>包的<code>At()</code>方法。</p></li><li><p>字符串并不总是utf8的文本，可以包含任意值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p><p>判断字符串是否是 UTF8 文本，可使用 “unicode/utf8” 包中的 <code>ValidString()</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>len(str)</code>返回的是字符串的字节数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取字符串的rune数是使用<code>unicode/utf8.RuneCountInString()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但注意一些字符也可能是由多个rune组成，如<code>é</code>是两个rune组成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;é&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;cafe\u0301&quot;</span>)    <span class="comment">// café    // 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python中的Unicode计算的是字符数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li><li><p>在Slice、Array、Map的多行书写最后的逗号不可省略，单行书写最后一个元素的逗号可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;    </span><br><span class="line">    z := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内置数据结构的操作并不同步，但可以把go提供了的并发特性使用起来：goroutines和channels。</p><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p><p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p></li><li><p>使用for range迭代string，是可以rune来迭代的。</p><p>一个字符，也可以有多个rune组成。需要处理字符，尽量使用<code>golang.org/x/text/unicode/norm</code>包。</p><p>for range总是尝试将字符串解析成utf8的文本，对于它无法解析的字节，它会返回<code>oxfffd</code>的rune字符。<br>因此，任何包含非utf8的文本，一定要先将其转换成字符切片(<code>[]byte</code>)再进行操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的。</p><p>Go 的运行时是有意打乱迭代顺序的，但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的.</p></li><li><p>switch的case默认匹配规则不同于其它语言的是，匹配case条件后默认退出(默认带上了break)，除非使用fallthrough继续匹配；而其它语言是默认继续匹配，除非使用break退出匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以改写 case 为多条件判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有后置自增（i++）、后置自减（i–），不存在前置自增、前置自减。同时 <code>++</code>、<code>—</code> 只作为运算符而非表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i            <span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">    fmt.Println(data[i++])    <span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>位运算的非操作是<code>^</code>（跟异或位运算一样），有别于其它语言的<code>~</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)        <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p><p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p><p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>位运算(与、或、异或、取反)优先级高于四则运算(加、减、乘、除、取余)，有别于C语言。</p><p>优先级列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Precedence              Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure></li><li><p>结构体在序列化( json、xml、gob 等格式)时，非导出字段（以小写字母开头的字段名）不会被encode，因此在decode时这些非导出字段的值为”0值”。</p></li><li><p>程序不等所有goroutine结束就会退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行 </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] is running</span><br><span class="line">[<span class="number">0</span>] is running</span><br><span class="line">all done!</span><br></pre></td></tr></table></figure><p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p><p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来好像 goroutine 都执行完了，然而报错：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p><p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于无缓存区的channel，写入channel的goroutine会阻塞直到被读取，读取channel的goroutine会阻塞直到有数据写入。</p><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从一个closed状态的channel读取数据是安全的，可通过返回状态（第二个返回参数）判断是否关闭。</p><p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code>。</p><p>而向一个closed状态的channel写数据会导致panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)        <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)            <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)    <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向一个<code>nil</code>值（未用make分配空间）的channel发送或读取数据，会导致永远阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get first result</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;result:&quot;</span>,&lt;-ch)</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runtime 死锁错误：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!<br>goroutine 1 [chan receive (nil chan)]</p></blockquote><p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = inCh</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inCh</span><br><span class="line">            <span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">                out = outCh</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inCh &lt;- <span class="number">1</span></span><br><span class="line">    inCh &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法接收者是类型（T），接收者只是原对象的值复制，在方法中修改接收者不会修改原始对象的值；如果方法接收者是指针类型（*T），是对原对象的引用，方法中对其修改当然是原对象修改。</p><p>换句话说，方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p><p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">    key *<span class="keyword">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span> <span class="title">pmethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span> <span class="title">vmethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">&quot;v.key&quot;</span></span><br><span class="line">    this.items[<span class="string">&quot;vmethod&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="keyword">int</span></span><br><span class="line">    key   *<span class="keyword">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span> <span class="title">pointerFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span> <span class="title">valueFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">    this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc()    <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()    <span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>log包中的<code>log.Fata</code>l和<code>log.Panic</code>不仅仅记录日志，还会中止程序。它不同于<code>Logging</code>库。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 初级 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库怎么创建？</title>
      <link href="/2021/06/20/mysql/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%EF%BC%9F/"/>
      <url>/2021/06/20/mysql/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>从这篇文章开始，创建一个数据库吧~</p><span id="more"></span><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] db_name [create_specification [,craete_specification]... ]</span><br><span class="line"></span><br><span class="line"><span class="comment">--create_specification（可选参数）:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[DEFAULT] CHARACTER SET charset_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[DEFAULT] COLLATE collation_name</span></span><br></pre></td></tr></table></figure><ul><li>CHARACTER SET：指定数据库采用的字符集，如果不指定字符集，默认utf8</li><li>COLLATE：指定数据库字符集的校对规则（常用的utf8_bin（区分大小写）、utf8_general_ci （不区分大小写）注意默认是utf8_general_ci）[举例说明 database.sql 文件]</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1.创建一个名为lsx_db01的数据库（图形化和指令）</p><ul><li><p> 图形化方式略，右键当前连接即可</p></li><li><p>使用指令创建数据库如下：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#使用指令创建数据库，后面分号不要忘记</span><br><span class="line"><span class="keyword">create</span> database lsx_01;</span><br><span class="line">#注意，在创建数据库和表的时候，为了规避关键字，可以使用反引号解决。</span><br><span class="line">#例如：<span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`,创建一个叫做“<span class="keyword">CREATE</span>”的数据库</span><br><span class="line"></span><br><span class="line">#删除数据库指令，<span class="keyword">drop</span>和<span class="keyword">DROP</span>都可以，大小写不敏感</span><br><span class="line"><span class="keyword">DROP</span> DATABASE lsx_01;</span><br></pre></td></tr></table></figure><p>2.创建一个使用utf8字符集的lsx_db02数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE lsx_02 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br></pre></td></tr></table></figure><p>3.创建一个使用utf8字符集，并附带校对规则的lsx_db03数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE lsx_03 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br></pre></td></tr></table></figure><p>如果表没有指定字符集和校对规则，则使用的是这个表所属数据库的字符集和校对规则。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>不同的校对规则有什么影响？</p><p>可能会影响查询结果。若不区分大小写，则会将所有查询到的结果显示出来，包括大写和小写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 概念篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原来一整天不喝水也没什么特别</title>
      <link href="/2021/06/18/%E4%B8%80%E6%95%B4%E5%A4%A9%E4%B8%8D%E5%96%9D%E6%B0%B4%E4%B9%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB/%E4%B8%80%E6%95%B4%E5%A4%A9%E4%B8%8D%E5%96%9D%E6%B0%B4%E4%B9%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB/"/>
      <url>/2021/06/18/%E4%B8%80%E6%95%B4%E5%A4%A9%E4%B8%8D%E5%96%9D%E6%B0%B4%E4%B9%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB/%E4%B8%80%E6%95%B4%E5%A4%A9%E4%B8%8D%E5%96%9D%E6%B0%B4%E4%B9%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>没什么特别的一天，</p><p>在405呆了一整个早上和下午。。</p><span id="more"></span><p>从靠北的窗户看到睡醒的柯岩扛着被子去阳台晒，</p><p>立即双手合十，开始虔诚祈雨。。</p><p>淋死你，林死你</p><p>哎，不说话不容易渴，</p><p>一瓶脉动桌角摆了一天，都没拧开盖子</p><p>大概沉默是不知怎么面对吧</p><p>毕竟纠缠太多会被讨厌</p><p>张佳同学说的对，大概自己，情商太低</p><p>那个时候我看着他边说边拿起我桌子上过期的饼干来吃，</p><p>也会怀疑自己是不是真的是个傻b？</p><p>乐乐实习回来，要跟以色列小哥踢球，</p><p>而自己竟然不是很想动——</p><p>找各种借口不踢球？？<br>我的妈，谁在控制我大脑，get out！</p><p>这样也还可以吧，</p><p>安静不打扰，给彼此松绑，松口气~</p><p>前晚的反应有点伤。。我又开始羡慕他，</p><p>怎么可以那样自然的相处</p><p>明天又是论文新一轮考核。。</p><p>趴在桌子上尽量不想微分方程之外的事情，</p><p>思绪乱成一团麻</p><p>索性看b站段子，一条一条地刷，</p><p>但果然段子只能逗笑本来心情就不坏的人</p><p>我开始觉得这夜好难撑过去，</p><p>你可以帮我数羊吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 小小 </tag>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
